# 基础命令
```shell
ansible
ansible-doc
ansible-playbook
ansible-vault
ansible-console
ansible-galaxy
ansible-pull
```

# ansible命令
>ansible通过ssh实现配置管理、应用部署、任务执行等功能
>建议配置ansible端能基于密钥认证的方式联系各被管理节点

```shell
ansible <host-pattern> [-m module_name] [-a args]
# ansible +被管理的主机(ALL) +模块  +参数
    --version              显示版本
    -m module              指定模块，默认为command
    -v                     详细过程 –vv -vvv更详细
    --list-hosts           显示主机列表，可简写 --list
    -k, --ask-pass         提示输入ssh连接密码,默认Key验证
    -C, --check            检查，并不执行
    -T, --timeout=TIMEOUT  执行命令的超时时间,默认10s
    -u, --user=REMOTE_USER 执行远程执行的用户
    -b, --become           代替旧版的sudo切换
        --become-user=USERNAME 指定sudo的runas用户,默认为root
    -K, --ask-become-pass  提示输入sudo时的口令
```

![[Pasted image 20230811210730.png]]
## 查看主机列表



![[Pasted image 20230811193150.png]]
## host-pattern

匹配主机的列表，对于逻辑条件，推荐使用单引号括起来
* all：ansible all –m ping
* 通配符*：
```shell
ansible "*" -m ping  # *表示所有主机
ansible 192.168.1.* -m ping
ansible "*srvs" -m ping
## ssh登录&ping
```

* 或关系 `:`

取得并集
```
ansible "websrvs:appsrvs" -m ping
ansible “192.168.1.10:192.168.1.20” -m ping
```

* 逻辑与 `:&`

取得交集
```
# 在websrvs组并且在dbsrvs组中的主机
ansible "websrvs:&dbsrvs" –m ping
```

* 逻辑非 `:!`

注意：此处为单引号
```
# 表示Ip在websrvs组，但不在dbsrvs组中的主机的
ansible 'websrvs:!dbsrvs' –m ping
```
![[Pasted image 20230811195737.png]]

* 综合逻辑
注意：此处为单引号
```
ansible 'websrvs:dbsrvs:&appsrvs:!ftpsrvs' –m ping
```

* 正则表达式
```
ansible "websrvs:&dbsrvs" –m ping
ansible "~(web|db).*\.stt\.com" –m ping
```
## SSH/ping
*测试主机是否连通* 
>检测所有主机的网络状态，默认情况下连接被管理的主机是ssh基于key验证,如果没有配置key，权限将会被拒绝
 因此需要指定以谁的身份连接,输入用户密码,必须保证被管理主机用户密码一致
 ansible all -m ping -k
 或者实现基于key验证 将公钥ssh-copy-id到被管理的主机上 , 实现免密登录
 ansible all -m ping
### ssh有密码登录
ansible 192.168.127.136 -m ping -k

> k表示输入密码，-m表示指定模块，ansible的Ping是模块，用的还是ssh协议

![[Pasted image 20230811100638.png]]
### ssh无密码登录
步骤：
1. 在主控端生成密钥对：ssh-keygen
2. 将生成的公钥上传到被管理端：ssh-copy-id root@IP

[root@k8smaster ~]# ==ssh-keygen==
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:3yA5dkU/ROvliBiKUb2fHrW2tNMQDGE6HGcyquSHfUw root@k8smaster
The key's randomart image is:
+---[RSA 2048]----+
|        ..+ *oo  |
|       . o.X.o . |
|      o . E..o+ .|
|     o * =.= o+= |
|      = S *..ooo.|
|       o * o+ =  |
|          ...+ = |
|            . + .|
|               . |
+----[SHA256]-----+

上传到被管理端
[root@k8smaster ~]# ssh-copy-id root@192.168.127.135
[root@k8smaster ~]# ssh-copy-id root@192.168.127.136
> 如果也想主控端ping主控端不需要密码，还是要将秘钥上传到主控端去，不然主控端还是得输密码



![[Pasted image 20230811102556.png]]

![[Pasted image 20230811103537.png]]

## 命令执行过程
1. 加载自己的配置文件，默认/etc/ansible/ansible.cfg
2. 加载自己对应的模块文件，如command
3. 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件
4. 给文件+x执行
5. 执行并返回结果
6. 删除临时py文件，sleep 0退出

### 执行状态

- 绿色：执行成功并且不需要做改变的操作
- 黄色：执行成功并且对目标主机做变更
- 红色：执行失败

使用-vv查看执行过程，如果使用-vvv可以查看更加详细的步骤

```sehll
[root@linux101 ~]# ansible 192.168.10.103 -m ping -vv
ansible 2.9.27
  config file = /etc/ansible/ansible.cfg
  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python2.7/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 2.7.5 (default, Nov 16 2020, 22:23:17) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]
Using /etc/ansible/ansible.cfg as config file
Skipping callback 'actionable', as we already have a stdout callback.
Skipping callback 'counter_enabled', as we already have a stdout callback.
Skipping callback 'debug', as we already have a stdout callback.
Skipping callback 'dense', as we already have a stdout callback.
Skipping callback 'dense', as we already have a stdout callback.
Skipping callback 'full_skip', as we already have a stdout callback.
Skipping callback 'json', as we already have a stdout callback.
Skipping callback 'minimal', as we already have a stdout callback.
Skipping callback 'null', as we already have a stdout callback.
Skipping callback 'oneline', as we already have a stdout callback.
Skipping callback 'selective', as we already have a stdout callback.
Skipping callback 'skippy', as we already have a stdout callback.
Skipping callback 'stderr', as we already have a stdout callback.
Skipping callback 'unixy', as we already have a stdout callback.
Skipping callback 'yaml', as we already have a stdout callback.
META: ran handlers
192.168.10.103 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
META: ran handlers
META: ran handlers
```

## 使用示例
```sehll
# 以wang用户执行ping存活检测
ansible all -m ping -u wang -k

# 以wang sudo至root执行ping存活检测，-b默认使用root用户
ansible all -m ping -u wang -k -b

# 以wang sudo至mage用户执行ping存活检测
ansible all -m ping -u wang -k -b --become-user=mage

# 以wang sudo至root用户执行ls,-k 表示wang的password ,-K 表示root的password
ansible all -m command -u wang -a 'ls /root' -b --become-user=root -k -K

# ansible ping模块测试连接
ansible 192.168.38.126,192.168.38.127 -m ping -k 

```

# ansible-doc命令

显示帮助模块
```shell
ansible-doc [options] [module...]
    -a            显示所有模块的文档 # 不常用，显示太多
    -l, --list    列出可用模块 # 常用
    -s, --snippet 显示指定模块的playbook片段(简化版,便于查找语法)
```

列出所有模块
ansible-doc -l

查看指定模块的帮助信息
ansible-doc 模块名
![[Pasted image 20230811201010.png]]

查看指定模块的简化帮助
![[Pasted image 20230811201128.png]]


# ansible-galaxy 命令
ansible-galaxy 是 Ansible 的一个命令行工具，用于管理和分享 Ansible 角色。

> Ansible 角色是一种可重用的组织单位，可以用于在 Ansible 项目中共享和复用代码。

`ansible-galaxy` 命令用于执行以下操作
* 搜索角色：你可以使用 `ansible-galaxy search` 命令搜索 Ansible Galaxy 角色库中的角色。例如，要搜索名为 "nginx" 的角色，可以运行以下命令：

    ansible-galaxy search nginx

* 安装角色：使用 `ansible-galaxy install` 命令可以安装一个或多个角色到本地系统。你可以指定角色的名称和版本。例如，要安装名为 "nginx" 的角色，可以运行以下命令：
    
    ansible-galaxy install nginx
    
- 列出已安装的角色：使用 `ansible-galaxy list` 命令可以列出已经安装在本地系统上的角色及其版本信息。例如：
    ansible-galaxy list

- 移除角色：你可以使用 `ansible-galaxy remove` 命令从本地系统中移除一个已安装的角色。例如，要移除名为 "nginx" 的角色，可以运行以下命令：
    
    ansible-galaxy remove nginx

- 创建角色：`ansible-galaxy init` 命令用于创建一个新的 Ansible 角色模板。你可以指定角色的名称和路径。例如，要创建一个名为 "myrole" 的角色，可以运行以下命令：
   
   ansible-galaxy init myrole

# ansible-pull 命令
`ansible-pull` 是 Ansible 的一种用法，用于在远程主机上执行 Ansible Playbook，从而实现自动配置和管理。与传统的 Ansible 执行模式不同，`ansible-pull` 的工作方式是在远程主机上运行，而不是从控制节点远程控制主机。

`ansible-pull` 命令用于执行以下操作：

1. 下载 Ansible Playbook：`ansible-pull` 命令会从 Git 存储库或指定的 URL 下载 Ansible Playbook 文件。
    
2. 执行 Playbook：一旦下载完成，`ansible-pull` 命令会立即在本地主机上运行 Ansible Playbook。
    
3. 自动配置和管理：Ansible Playbook 的内容通常包含了在远程主机上进行配置和管理的任务，例如安装软件包、配置文件、服务等。

`ansible-pull` 命令的基本语法如下

```
ansible-pull [选项] [URL]
```

* 其中，`URL` 可以是指向 Ansible Playbook 的 Git 存储库的 URL，或者是直接指定的 Playbook 文件的 URL。

* 例如，以下命令从 Git 存储库下载并执行 Ansible Playbook：
```
ansible-pull -U <Git Repository URL>
```

* 或者，直接指定 Playbook 文件的 URL：

```
ansible-pull -U <Playbook URL>
```

# ansible-playbook 命令
# ansible-vault 命令
`ansible-vault` 是 Ansible 提供的一个命令行工具，用于加密和解密敏感数据，例如密码、密钥、API 密钥等。`ansible-vault` 命令可以让你在 Ansible 项目中安全地存储和管理这些敏感数据。

下面是一些常见的 `ansible-vault` 命令用法和示例：

1. 创建一个新的加密文件：

```
ansible-vault create secrets.yml
```

该命令将创建一个名为 `secrets.yml` 的新文件，并要求你设置一个密码。然后，你可以使用编辑器打开该文件并添加敏感数据。

2. 编辑一个已加密的文件：

```
ansible-vault edit secrets.yml
```

该命令将打开一个已加密的文件，并要求你输入密码以解密文件内容。然后，你可以使用编辑器编辑文件内容。

3. 查看一个已加密的文件：

```
ansible-vault view secrets.yml
```

该命令将显示已加密文件的内容，但不会解密它。

4. ==加密一个未加密的文件==：

```
ansible-vault encrypt secrets.yml
```

该命令将对未加密的文件进行加密，并要求你设置一个密码。加密后，原始文件将被覆盖。

5. 解密一个已加密的文件：

```
ansible-vault decrypt secrets.yml
```

该命令将解密一个已加密的文件，并要求你输入密码。解密后，原始文件将被覆盖。

6. 重新加密一个已加密的文件：

```
ansible-vault rekey secrets.yml
```

该命令将更改一个已加密文件的密码。你将被要求提供当前密码和新密码。

7.==对其解密==
```
ansible-vault decrypt secrets.yml
```
# ansible-console命令
